C51 COMPILER V9.60.7.0   LCD_INTERFACING__WITH_FUNCTIONS_                                  12/26/2024 18:04:51 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LCD_INTERFACING__WITH_FUNCTIONS_
OBJECT MODULE PLACED IN .\Objects\LCD Interfacing (with functions).obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE LCD Interfacing (with functions).c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECT
                    -EXTEND PRINT(.\Listings\LCD Interfacing (with functions).lst) TABS(2) OBJECT(.\Objects\LCD Interfacing (with functions).
                    -obj)

line level    source

   1          #include<reg51.h>
   2          sbit rs = P1^0;
   3          sbit en = P1^1;
   4          
   5          void delay(unsigned int count)
   6          {
   7   1        unsigned int i;
   8   1        while(count)
   9   1        {
  10   2          i = 115;
  11   2          while(i > 0)
  12   2            i--;
  13   2          count--;
  14   2        }
  15   1      }
  16          
  17          void lcd_cmd(unsigned char abc)  //Funtion for sending commands to LCD display
  18          {
  19   1        rs = 0;
  20   1        en = 1;
  21   1        P2 = abc;
  22   1        delay(50);
  23   1        en = 0;
  24   1      }
  25          
  26          void lcd_init()
  27          {
  28   1        lcd_cmd(0x38) ;  // initialize
  29   1        lcd_cmd (0x02);  //return home
  30   1        lcd_cmd(0x01);   //clear display
  31   1        lcd_cmd(0x0C);   //Display ON cursor OFF
  32   1        lcd_cmd(0x06) ;   //Increment cursor (shift cursor to the right)
  33   1      }
  34          
  35          void lcd_printchar(unsigned char abc)   //Funtion to print to LCD display (recieves only one character at 
             -a time)
  36          {
  37   1        rs = 1;
  38   1        en = 1;
  39   1        P2 = abc;
  40   1        delay(50);
  41   1        en = 0;
  42   1      }
  43          
  44          void lcd_printstring(unsigned char text[])   //My own generated function (recieves entire string/text at a
             - time)
  45          {
  46   1        unsigned int n=0, i;
  47   1        while(text[n] != '\0')  //calculates number of characters in text/string
  48   1        {
  49   2            n++;
  50   2        }
  51   1        for (i=0 ; i<n ; i++)  //prints each character of given text/string at a time
C51 COMPILER V9.60.7.0   LCD_INTERFACING__WITH_FUNCTIONS_                                  12/26/2024 18:04:51 PAGE 2   

  52   1        {
  53   2          rs = 1;
  54   2          en = 1;
  55   2          P2 = text[i];
  56   2          delay(50);
  57   2          en = 0;
  58   2        }
  59   1      }
  60          
  61          void lcd_clear()
  62          {
  63   1        lcd_cmd(0x01);   //clear display
  64   1      }
  65          
  66          void lcd_setcursor(unsigned int row, unsigned int column)
  67          {
  68   1        unsigned int address;
  69   1        if(row == 0)
  70   1        {
  71   2          if(column <= 15)
  72   2          {
  73   3            address = 0x80 + column;   //Address where lcddata should be printed (0x80 means row=0,column=0) i.e ad
             -dress is from 0x80 to 0x8F
  74   3            lcd_cmd(address);
  75   3          }
  76   2          else
  77   2          {
  78   3            address = 0x80;
  79   3            lcd_cmd(address);
  80   3            lcd_printstring("Address ERROR");
  81   3          }
  82   2        }
  83   1        else if(row == 1)
  84   1        {
  85   2          if(column <= 15)
  86   2          {
  87   3            address = 0xC0 + column;   //Address where lcddata should be printed (0x80 means row=1,column=0) i.e ad
             -dress is from 0xC0 to 0xCF
  88   3            lcd_cmd(address);
  89   3          }
  90   2          else
  91   2          {
  92   3            address = 0xC0;
  93   3            lcd_cmd(address);
  94   3            lcd_printstring("Address ERROR");
  95   3          }
  96   2        }
  97   1        else
  98   1        {
  99   2          lcd_printstring("Address ERROR");
 100   2        }
 101   1      }
 102          
 103          void lcd_printnumber(unsigned int num)   //My own generated function (recieves a number, converts to strin
             -g & prints it)
 104          {
 105   1        unsigned int revnum=0,i,n=0;
 106   1        unsigned char str[5];     //NOTE:8051 can only print whole numbers from 0 to 65535(0xFFFF) i.e highest 16
             --bits number
 107   1        
 108   1        while(num!=0)
 109   1        {
C51 COMPILER V9.60.7.0   LCD_INTERFACING__WITH_FUNCTIONS_                                  12/26/2024 18:04:51 PAGE 3   

 110   2          revnum = revnum*10 + num%10;   //Obtaining the reversed form of given number
 111   2          num = num/10;
 112   2          n++;      //Counting the number of digits in given number
 113   2        }
 114   1        
 115   1        for(i=0 ; i<n ; i++)
 116   1        {
 117   2          str[i] = revnum%10 + '0';   //Obtaining string from reversed form of given number
 118   2          revnum = revnum/10;
 119   2        }
 120   1        str[n] = '\0';                //NULL-terminating the string
 121   1        
 122   1        for (i=0 ; i<n ; i++)      //prints each character of given text/string at a time
 123   1        {
 124   2          rs = 1;
 125   2          en = 1;
 126   2          P2 = str[i];
 127   2          delay(50);
 128   2          en = 0;
 129   2        }
 130   1      }
 131          
 132          void lcd_clearRow(unsigned int row)
 133          {
 134   1        unsigned int i;
 135   1        if(row==0)    //Clear first row
 136   1        {
 137   2          lcd_cmd(0x80);
 138   2          for (i=1 ; i<=16 ; i++)
 139   2          {
 140   3            lcd_printstring(" ");   //Use lcd_printstring() to print space i.e lcd_printchar() prints random chars
 141   3          }
 142   2          lcd_cmd(0x80);
 143   2        }
 144   1        else if(row==1)   //Clear second row
 145   1        {
 146   2          lcd_cmd(0xC0);
 147   2          for (i=1 ; i<=16 ; i++)
 148   2          {
 149   3            lcd_printstring(" ");
 150   3          }
 151   2          lcd_cmd(0xC0);
 152   2        }
 153   1        else    //Clears All rows i.e clears entire display
 154   1        {
 155   2          lcd_cmd(0x01);
 156   2        }
 157   1      }
 158          
 159          void main()
 160          {
 161   1        lcd_init();
 162   1        
 163   1        while(1)
 164   1        {
 165   2          lcd_clear();
 166   2          lcd_setcursor(0,0);
 167   2          lcd_printstring("Hello Seth");
 168   2          lcd_setcursor(1,0);
 169   2          lcd_printstring("Welcome");
 170   2          delay(1000);
 171   2        
C51 COMPILER V9.60.7.0   LCD_INTERFACING__WITH_FUNCTIONS_                                  12/26/2024 18:04:51 PAGE 4   

 172   2          lcd_clear();
 173   2          lcd_setcursor(0,0);
 174   2          lcd_printstring("8051 Project");
 175   2          lcd_setcursor(1,0);
 176   2          lcd_printstring("LCD Interfacing");
 177   2          delay(1000);
 178   2          
 179   2          lcd_clear();
 180   2          lcd_setcursor(0,0);
 181   2          lcd_printstring("Random Number");
 182   2          lcd_setcursor(1,0);
 183   2          lcd_printnumber(60050);    //NOTE:Can only print whole numbers from 0 to 65535(0xFFFF) i.e highest 16-b
             -its number
 184   2          delay(1000);
 185   2          
 186   2          lcd_clearRow(0);
 187   2          lcd_printstring("Percentage");
 188   2          lcd_clearRow(1);
 189   2          lcd_printnumber(85);
 190   2          lcd_printchar('%');
 191   2          delay(1000);
 192   2        }
 193   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    695    ----
   CONSTANT SIZE    =     89    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
